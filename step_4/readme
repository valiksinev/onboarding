    Practical introduction to the asynchronous and multithreaded tasks.

1. Calculate three factorials in three asynchronous tasks. Then try to do the same calculations spawing three threads.
Compare the time execution.

let futures = (0..3).map(|_| {
        test()
    });

async fn test() {
    for _ in 0..10_000_000 {
        let _ = factorial(30);
    }
}

fn factorial(n: u128) -> u128 {
    (1..n+1).fold(1, |a, b| a * b)
}


To run async tasks use futures_util.
To spawn threads use tokio.


2.    Sending batch of Solana transactions on client side.
Distribute the funds across N recipients from the single account.
Send transactions in parallel as match as possible.
Number of receivers must be arbitrary (it doesn't have to be a multiple of 2^x.).
To run batch of transaction use async mode to execute send_and_confirm_transaction();

input: number to receivers
amount: 1 (doesn't matter, const value)

    transaction scheme:

tx1:                           genesis_account
                                 |
                                 a1


batch 2:                       genesis_account
                                 |       |
                                 a1      |
                                 |       |
                                 b1      b2

batch 3:                       genesis_account
                                 |       |    |
                                 a1--|   |    |
                                 |   |   |    |
                                 b1  |   b2   |
                                 |   |   |    |
                                 c1  c2  c3   c4

                                        ....
batch 4:                        d1 d2 d3 d4 d5 d6 d7 d8
...


3. Semaphore
Create file that contains 100 Solana pubkeys:

9ArXGjava7FzUPC3QqBYDDiXZjPkB3zPAtv9N78NEDnB
DErdwpF4CRVbeCxfkBz7sDxxAdTLaZ9ehkiLj6rkGLhU
9TZ4zNKk2vrp5zEsrTatkgoK19JFAgLQ1D3oLx2j111X
....

On clinet side call the transfer instruction of your hello_world contract to airdrop funds to these accounts.
You need to spawn tasks. Each task calls the rpc_client.send_and_confirm_transaction().
Use the semaphore to limit the number of spawned tasks by 10.



